# Conceptos Avanzados de Pinia

## Persistencia de Estado

Para mantener el estado entre recargas de página, puedes usar `pinia-plugin-persistedstate`:

```bash
npm install pinia-plugin-persistedstate
```

Configuración en tu aplicación (generalmente en `main.ts` o `main.js`):

```typescript
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'
import App from './App.vue'

const app = createApp(App)
const pinia = createPinia()

// Usar el plugin de persistencia
pinia.use(piniaPluginPersistedstate)

app.use(pinia)
app.mount('#app')
```

Luego, en tu store con Composition API:

```typescript
// stores/user.ts
import { defineStore } from 'pinia'

export const useUserStore = defineStore('user', () => {
  // Estado
  const user = ref<{id: string, name: string, email: string} | null>(null)
  const preferences = ref({
    theme: 'light',
    notifications: true,
    language: 'es',
  })
  
  // Acciones
  function login(userData: {id: string, name: string, email: string}) {
    user.value = userData
  }
  
  function updatePreferences(newPreferences: Partial<typeof preferences.value>) {
    preferences.value = { ...preferences.value, ...newPreferences }
  }
  
  return {
    // Estado
    user,
    preferences,
    
    // Acciones
    login,
    updatePreferences,
    
    // Configuración de persistencia
    // Opción 1: Persistir todo el estado
    persist: true,
    
    // Opción 2: Configuración avanzada
    /*
    persist: {
      paths: ['user'], // Solo persistir el usuario
      storage: sessionStorage, // Usar sessionStorage en lugar de localStorage
      key: 'user-storage', // Clave personalizada para el almacenamiento
    }
    */
  }
}, {
  // Configuración de persistencia como segundo argumento (opcional)
  persist: {
    paths: ['user'],
    storage: localStorage,
  }
})
```

## Módulos y Stores Anidados

Puedes organizar tu lógica en múltiples stores y usarlos juntos:

```typescript
// stores/user.ts
export const useUserStore = defineStore('user', () => {
  // Estado
  const name = ref('Usuario')
  const isAuthenticated = ref(false)
  
  // Acciones
  function login() {
    isAuthenticated.value = true
  }
  
  return {
    name,
    isAuthenticated,
    login
  }
})

// stores/cart.ts
export const useCartStore = defineStore('cart', () => {
  // Estado
  const items = ref<Array<{id: number, name: string, price: number}>>([])
  
  // Getters
  const totalItems = computed(() => items.value.length)
  const totalPrice = computed(() => 
    items.value.reduce((total, item) => total + item.price, 0)
  )
  
  // Acciones
  function addItem(item: {id: number, name: string, price: number}) {
    items.value.push(item)
  }
  
  function removeItem(itemId: number) {
    const index = items.value.findIndex(item => item.id === itemId)
    if (index !== -1) {
      items.value.splice(index, 1)
    }
  }
  
  return {
    items,
    totalItems,
    totalPrice,
    addItem,
    removeItem
  }
})

// En un componente
<script setup lang="ts">
import { useUserStore } from '@/stores/user'
import { useCartStore } from '@/stores/cart'
import { useRouter } from 'vue-router'

const user = useUserStore()
const cart = useCartStore()
const router = useRouter()

// Usar ambos stores juntos
const checkout = () => {
  if (user.isAuthenticated) {
    // Procesar compra
    console.log('Procesando compra...', cart.items)
    // Aquí iría la lógica de checkout
  } else {
    // Redirigir a login
    router.push('/login')
  }
}
</script>

<template>
  <div>
    <h1>Carrito de Compras</h1>
    <p v-if="!user.isAuthenticated">
      Por favor <button @click="user.login">inicia sesión</button> para continuar.
    </p>
    <div v-else>
      <p>Bienvenido, {{ user.name }}</p>
      <div v-if="cart.totalItems > 0">
        <p>Productos en el carrito: {{ cart.totalItems }}</p>
        <p>Total: ${{ cart.totalPrice.toFixed(2) }}</p>
        <button @click="checkout">Finalizar Compra</button>
      </div>
      <p v-else>Tu carrito está vacío</p>
    </div>
  </div>
</template>
```

## Testing con Pinia

Para probar tus stores, puedes usar `@vue/test-utils` junto con Pinia. Aquí te muestro cómo configurar y escribir pruebas para un store con Composition API:

```bash
npm install -D @vue/test-utils @vue/vue3-jest @testing-library/vue @testing-library/jest-dom
```

### Configuración básica de pruebas

Crea un archivo de configuración para Jest (por ejemplo, `jest.config.js`):

```javascript
module.exports = {
  testEnvironment: 'jsdom',
  moduleFileExtensions: ['js', 'ts', 'json', 'vue'],
  transform: {
    '^.+\.tsx?$': 'ts-jest',
    '^.+\.vue$': '@vue/vue3-jest',
    '^.+\.js$': 'babel-jest',
  },
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  testMatch: ['**/__tests__/**/*.spec.[jt]s?(x)'],
}
```

### Ejemplo de prueba para un store

```typescript
// __tests__/stores/counter.spec.ts
import { setActivePinia, createPinia } from 'pinia'
import { useCounterStore } from '@/stores/counter'

describe('Counter Store', () => {
  // Crea una nueva instancia de Pinia antes de cada prueba
  beforeEach(() => {
    setActivePinia(createPinia())
  })

  it('inicializa con contador en 0', () => {
    const counter = useCounterStore()
    expect(counter.count).toBe(0)
  })

  it('incrementa el contador correctamente', () => {
    const counter = useCounterStore()
    counter.increment()
    expect(counter.count).toBe(1)
  })

  it('reinicia el contador correctamente', () => {
    const counter = useCounterStore()
    counter.increment()
    counter.increment()
    counter.$reset()
    expect(counter.count).toBe(0)
  })
})
```

### Probando un componente que usa Pinia

```typescript
// __tests__/components/Counter.spec.ts
import { mount } from '@vue/test-utils'
import { createTestingPinia } from '@pinia/testing'
import Counter from '@/components/Counter.vue'

describe('Counter.vue', () => {
  it('muestra el contador y responde a los clics', async () => {
    const wrapper = mount(Counter, {
      global: {
        plugins: [
          createTestingPinia({
            createSpy: vi.fn, // Usa vi.fn de Vitest o jest.fn de Jest
            initialState: {
              counter: { count: 5 } // Estado inicial para la prueba
            }
          })
        ]
      }
    })

    // Verifica que el contador muestre el valor inicial
    expect(wrapper.find('p').text()).toContain('5')
    
    // Simula un clic en el botón de incrementar
    await wrapper.find('button').trigger('click')
    
    // Verifica que el contador se haya incrementado
    expect(wrapper.find('p').text()).toContain('6')
  })
})
```

### Mockeando acciones del store

```typescript
// __tests__/components/UserProfile.spec.ts
import { mount } from '@vue/test-utils'
import { createTestingPinia } from '@pinia/testing'
import UserProfile from '@/components/UserProfile.vue'

describe('UserProfile.vue', () => {
  it('llama a fetchUser al montar el componente', async () => {
    const mockUser = { id: 1, name: 'Usuario de prueba' }
    
    const wrapper = mount(UserProfile, {
      global: {
        plugins: [
          createTestingPinia({
            createSpy: vi.fn,
            stubActions: false, // Permite espiar las acciones
            initialState: {
              user: { user: null }
            }
          })
        ]
      }
    })

    const userStore = useUserStore()
    
    // Mock de la acción fetchUser
    userStore.fetchUser = vi.fn().mockResolvedValue(mockUser)
    
    // Forzar la ejecución de onMounted
    await wrapper.vm.$nextTick()
    
    // Verificar que se llamó a fetchUser
    expect(userStore.fetchUser).toHaveBeenCalledTimes(1)
    
    // Simular que la promesa se resuelve
    await userStore.fetchUser()
    
    // Verificar que el estado se actualizó correctamente
    expect(userStore.user).toEqual(mockUser)
  })
})
```
```

## Integración con Vue Router

Puedes usar Pinia junto con Vue Router para la navegación protegida:

```javascript
// router/index.js
import { createRouter, createWebHistory } from 'vue-router'
import { useUserStore } from '@/stores/user'

const routes = [
  {
    path: '/dashboard',
    component: () => import('@/views/Dashboard.vue'),
    meta: { requiresAuth: true }
  },
  // Otras rutas...
]

const router = createRouter({
  history: createWebHistory(),
  routes,
})

router.beforeEach((to, from, next) => {
  const userStore = useUserStore()
  
  if (to.meta.requiresAuth && !userStore.isAuthenticated) {
    next('/login')
  } else {
    next()
  }
})

export default router
```

## Uso con TypeScript

Pinia tiene soporte de primera clase para TypeScript. Aquí hay un ejemplo de un store tipado:

```typescript
// types/user.ts
export interface User {
  id: number
  name: string
  email: string
}

// stores/user.ts (Composition API)
import { defineStore } from 'pinia'
import type { User } from '@/types/user'

export const useUserStore = defineStore('user', () => {
  // Estado tipado
  const user = ref<User | null>(null)
  const loading = ref<boolean>(false)
  const error = ref<string | null>(null)

  // Getter tipado
  const isAdmin: ComputedRef<boolean> = computed(() => {
    // @ts-expect-error role puede no existir en User básico; amplía tu tipo si lo usas
    return user.value?.role === 'admin'
  })

  // Acción tipada
  async function fetchUser(userId: number): Promise<void> {
    loading.value = true
    error.value = null
    try {
      const response = await fetch(`/api/users/${userId}`)
      const data: User = await response.json()
      user.value = data
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Error desconocido'
    } finally {
      loading.value = false
    }
  }

  return {
    user,
    loading,
    error,
    isAdmin,
    fetchUser,
  }
})
```

Con estos conceptos avanzados, podrás aprovechar al máximo Pinia en tus aplicaciones Vue 3.

## Siguiente paso

Ahora que has aprendido conceptos avanzados de Pinia, el siguiente paso es explorar la [Estructura de un Proyecto Práctico](../7-proyecto/7.1-estructura.md), donde verás cómo integrar todo lo aprendido en una aplicación completa.
